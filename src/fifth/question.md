## 3.静态变量和实例变量的区别?
静态变量属于类的级别，而实例变量属于对象的级别。

主要区别有两点：

1，存放位置不同

　　类变量随着类的加载存在于方法区中，实例变量随着对象的对象的建立存在于堆内存中。

2，生命周期不同

　　类变量的生命周期最长，随着类的加载而加载，随着类的消失而消失，

　　实例变量随着对象的消失而消失
## 4.接口和抽象类的区别？
他们都不能实例化对象，都可以包含抽象方法，而且抽象方法必须被继承的类全部实现。

区别：

1、抽象类和接口都不能直接实例化，如果要实例化，抽象类变量必须指向实现所有抽象方法的子类对象，接口变量必须指向实现所有接口方法的类对象。

2、抽象类要被子类继承，接口要被类实现。

3、接口只能做方法申明，抽象类中可以做方法申明，也可以做方法实现

4、接口里定义的变量只能是公共的静态的常量，抽象类中的变量是普通变量。

5、抽象类里的抽象方法必须全部被子类所实现，如果子类不能全部实现父类抽象方法，那么该子类只能是抽象类。同样，一个实现接口的时候，如不能全部实现接口方法，那么该类也只能为抽象类。

6、抽象方法只能申明，不能实现，接口是设计的结果 ，抽象类是重构的结果

7、抽象类里可以没有抽象方法

8、如果一个类里有抽象方法，那么这个类只能是抽象类

9、抽象方法要被实现，所以不能是静态的，也不能是私有的。

10、接口可继承接口，并可多继承接口，但类只能单根继承
## 5.子类如何访问父类的有参构造?
如果父类有带参构造方法，子类必须重写带参构造方法，调用方法是super（），
参数个数和父类一样，并且super必须写在第一句，然后才能实现你的逻辑。
连任何定义语句都不行。
## 6.final,static关键字的特点
final 关键字主要用在三个地方：
对于 final 变量，如果是基本数据类型，则其数值在初始化后便不能更改；如果是引用类型，对其进行初始化后，便不能再指向另一个对象；

用 final 修饰类，表明这个类不能被继承，此时类中的所有成员方法，都会被隐式地指定为 final 方法；

使用 final 方法的原因有两个。第一个原因是把方法锁定，防止任何继承类修改它的含义；第二个原因是效率，早期的 Java 版本中，会将 final 方法转为内嵌调用，但是如果方法过于庞大，可能看不到内嵌调用带来的任何性能提升（如今已经不需要显示使用 final 方法来进行这些优化，类中所有的 private 方法会隐式地指定为 final）。

static 关键字主要有以下四种使用场景：
修饰成员变量和成员方法: 被 static 修饰的成员属于类，不属于这个类的某个对象，被类中所有的对象共享，可以并且建议通过类名进行调用。被 static 声明的成员变量属于静态成员变量，静态变量存放在 Java 内存区域的方法区，调用格式：类名.静态变量名、类名.静态方法名()；

静态代码块: 静态代码块定义在类中方法外, 静态代码块在非静态代码块之前执行(静态代码块—>非静态代码块—>构造方法)，当前类不管创建多少对象，静态代码块都只执行一次；

静态内部类（ static 修饰类的话只能修饰内部类）： 静态内部类与非静态内部类之间存在一个最大的区别: 非静态内部类在编译完成之后，会隐含地保存着一个引用，该引用指向创建它的外围类；但是静态内部类却没有，这意味着：1. 它的创建不需要依赖外围类的创建；2. 它不能使用任何外围类的非static成员变量和方法；

静态导包(用来导入类中的静态资源): 格式为：import static xxx，可以导入某个类中的指定静态资源，并且不需要显式使用类名来调用类中的静态成员和静态方法。


## 7.什么是方法的重载?什么是方法的重写？
【重载】是指在一个类里面可以有多个方法名字相同的不同方法。但是方法的参数个数，顺序，不能相同，否则如何区分调用这些方法。
【重写】是发生在当一个子类继承一个父类的时候，可以重写覆盖原来父类里面的方法（当然你也可以这几调用），当然这个方法和父类的方法名称一定要相同,参数也要相同，不然就不叫重写了。注意：有final修饰的方法不可以重写。